# [Item 28] 배열보다는 리스트를 사용하라

## 서론

자바에서 배열(Array)은 오래된 타입 시스템의 산물이고, 제네릭(List, Set 등)은 이후에 도입된 타입 안정성 장치다.
배열은 공변(covariant) 이라서 타입 안정성이 떨어지고, 제네릭은 불공변(invariant) 이라서 더 안전하다.
이 아이템에서는 배열의 한계를 살펴보고, 실무에서는 왜 List 같은 제네릭 컬렉션을 써야 하는지 정리한다.

---

## 문제점 1: 배열은 공변이라서 런타임 오류 가능

```java
Object[] arr = new Long[1];
arr[0] = "문자열"; // ❌ 컴파일 성공
```

실행하면:

```
Exception in thread "main" java.lang.ArrayStoreException: java.lang.String
```

- Long[]를 Object[]에 대입할 수 있게 허용(공변).
- 하지만 실제 저장 시점에 타입이 어긋나면 런타임 예외 발생.

---

## 문제점 2: 제네릭과 배열은 섞을 수 없음

```java
// ❌ 컴파일 에러: 제네릭 배열 생성 금지
List<String>[] stringLists = new List<String>[1];
```

- 제네릭은 소거(erasure) 로 런타임에 타입 정보가 사라짐.
- 배열은 런타임에 자기 타입을 체크하려 하므로, 제네릭과 충돌.

---

## 장점 1: 리스트는 컴파일 타임 타입 안정성 보장

```java
List<Object> list = new ArrayList<Long>(); // ❌ 컴파일 오류
```

→ 배열과 달리, 타입 불일치는 컴파일 단계에서 바로 차단된다.

---

## 장점 2: 제네릭과 자연스럽게 호환

```java
List<String> strings = new ArrayList<>();
strings.add("hello");
// strings.add(123); // ❌ 컴파일 오류
String s = strings.get(0); // 형변환 불필요, 안전
```

---

## 예외 상황: 배열이 더 나은 경우

- 기본형(primitive) 데이터 (int[], double[] 등) → 성능상 배열이 더 낫다.
- 수치 연산이나 대규모 처리에선 여전히 배열이 우세.
- 하지만 참조 타입 객체라면 기본은 List<T>를 사용해야 한다.

---

## 정리

1. 배열은 공변 → 런타임 오류 위험.
2. 제네릭은 불공변 → 컴파일 타임에 타입 안정성 확보.
3. 배열과 제네릭은 설계 철학이 달라서 함께 쓰면 위험하다.
4. 실무에서는 배열 대신 리스트를 기본으로 선택하라.
5. 다만 기본형 성능을 극대화해야 한다면 배열도 여전히 유효하다.